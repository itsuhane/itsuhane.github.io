---
title: Cholesky Game
layout: page
---
<script type="text/javascript">// <![CDATA[
  var headerHeight = 80;
  var boardMargin = 20;
  var boardSize = 500;
  var matrix;
  var canvas;
  var button;
  var sliderSize;
  var sliderRate;
  function GridPainter() {
    this.init = function (l, t, w, h, s) { this.l = l; this.t = t; this.w = w / s; this.h = h / s; this.tt = t + h; this.th = this.h / 5 }
    this.gridAt = function (i, j) { rect(this.l + i * this.w + 2, this.t + j * this.h + 2, this.w - 4, this.h - 4, 3); }
    this.tickAt = function (i, j) { rect(this.l + i * this.w + 2, this.tt + j * this.th + 2, this.w - 4, this.th - 1, 3); }
  }
  function Matrix() {
    this.init = function (size, sparsity) {
      this.size = size;
      this.data = [];
      for (var i = 0; i < this.size; ++i) {
        this.data[i] = [];
        for (var j = 0; j < this.size; ++j)
          if (j == i)
            this.data[i][j] = true;
          else if (j > i)
            if (random() < sparsity)
              this.data[i][j] = true;
            else
              this.data[i][j] = false;
          else
            this.data[i][j] = this.data[j][i];
        this.grid = new GridPainter();
      }
      this.progress = 0;
      this.pivot = -1;
      this.origCount = this.count();
    }
    this.count = function () {
      var num = 0;
      for (var i = 0; i < this.size; ++i)
        for (var j = 0; j < this.size; ++j)
          if (this.data[i][j]) num++;
      return num;
    }
    this.draw = function (l, t, w, h) {
      this.grid.init(l, t, w, h, this.size);
      noStroke();
      rectMode(CORNER);
      fill(143, 192, 69);
      var degs = [];
      var mindeg = this.size;
      var incs = [];
      for (var i = 0; i < this.size; ++i) {
        degs[i] = 0;
        for (var j = 0; j < this.size; ++j)
          if (this.data[i][j]) {
            if (j >= this.progress)
              degs[i]++;
            this.grid.gridAt(i, j);
          }
        if (i >= this.progress && degs[i] < mindeg)
          mindeg = degs[i];
      }
      fill(69, 143, 192);
      for (var i = this.progress; i < this.size; ++i)
        for (var j = 0; j < mindeg; ++j)
          this.grid.tickAt(i, j);
      fill(143, 192, 69);
      for (var i = this.progress; i < this.size; ++i)
        for (var j = mindeg; j < degs[i]; ++j)
          this.grid.tickAt(i, j);
      if (this.pivot >= this.progress && this.pivot < this.size) {
        fill(255, 160, 0);
        for (var i = this.progress; i < this.size; ++i) {
          incs[i] = 0;
          for (var j = this.progress; j < this.size; ++j)
            if (i != j && i != this.pivot && j != this.pivot && !this.data[i][j] && this.data[i][this.pivot] && this.data[this.pivot][j]) {
              this.grid.gridAt(i, j);
              incs[i]++;
            }
          for (var j = degs[i]; j < degs[i] + incs[i]; ++j)
            this.grid.tickAt(i, j);
        }
        fill(255, 0, 0, 61);
        rect(l + this.pivot * w / this.size, t, w / this.size, h, 3);
        rect(l, t + this.pivot * h / this.size, w, h / this.size, 3);
      }
      fill(255, 255, 255, 160);
      rect(l, t, w, this.progress * h / this.size);
      rect(l, t + this.progress * h / this.size, this.progress * w / this.size, (this.size - this.progress) * h / this.size);
      if (this.progress >= this.size) {
        rectMode(CENTER);
        textAlign(CENTER, CENTER);
        fill(255, 255, 255, 5);
        for (var i = width; i >= 50; i -= 10)
          rect(width / 2, headerHeight + boardSize / 2, i, i, 50);
        textSize(30);
        fill(73, 99, 35);
        text(this.origCount + '/' + this.count() + '/' + (this.size * this.size), width / 2, headerHeight + boardSize / 2, width, height);
      }
    }
    this.execute = function () {
      if (this.pivot >= this.progress && this.pivot < this.size) {
        for (var i = this.progress; i < this.size; ++i)
          for (var j = this.progress; j < this.size; ++j)
            if (i != j && i != this.pivot && j != this.pivot && !this.data[i][j] && this.data[i][this.pivot] && this.data[this.pivot][j])
              this.data[i][j] = true;
        var tmprow = this.data[this.pivot];
        for (var i = this.pivot; i > this.progress; --i)
          this.data[i] = this.data[i - 1];
        this.data[this.progress] = tmprow;
        tmprow = [];
        for (var i = 0; i < this.size; ++i)
          tmprow[i] = this.data[i][this.pivot];
        for (var i = this.pivot; i > this.progress; --i)
          for (var j = 0; j < this.size; ++j)
            this.data[j][i] = this.data[j][i - 1];
        for (var i = 0; i < this.size; ++i)
          this.data[i][this.progress] = tmprow[i];
        this.progress++;
        var num = 0;
        for (var i = this.progress; i < this.size; ++i)
          for (var j = this.progress; j < this.size; ++j)
            if (this.data[i][j])
              num++;
        if (num == (this.size - this.progress) * (this.size - this.progress) || num == (this.size - this.progress))
          this.progress = this.size;
      }
    }
    this.highlight = function (l, t, w, h, x, y) {
      var gridw = w / this.size;
      //var gridh=h/this.size;
      if (x >= l && y > t)
        this.pivot = (int)((x - l) / gridw);
      else
        this.pivot = -1;
    }
  }
  function Slider() {
    this.init = function (val, l, t, w, h) {
      this.val = val;
      this.cx = l + w / 2;
      this.cy = t + h / 2;
      this.w = w;
      this.h = h;
      this.hovered = false;
      this.pressed = false;
    }
    this.draw = function () {
      noStroke();
      rectMode(CENTER);
      if (this.pressed)
        fill(255, 160, 0);
      else if (this.hovered)
        fill(69, 143, 192);
      else
        fill(143, 192, 69);
      rect(this.cx, this.cy, this.w, 5, 3);
      var l = this.cx - this.w / 2;
      var r = this.cx + this.w / 2;
      var x = this.val * r + (1 - this.val) * l;
      rect(x, this.cy, 15, 15, 5);
    }
    this.hitTest = function (x, y, f) {
      if (this.pressed) {
        this.hovered = true;
        var rate = (x - (this.cx - this.w / 2)) / (float)(this.w);
        this.val = max(min(rate, 1), 0);
      } else if (x >= this.cx - this.w / 2 - 7.5 && x <= this.cx + this.w / 2 + 7.5 && y >= this.cy - this.h / 2 && y <= this.cy + this.h / 2)
        this.hovered = f;
      else
        this.hovered = false;
    }
    this.clickTest = function (x, y) {
      if (x >= this.cx - this.w / 2 - 7.5 && x <= this.cx + this.w / 2 + 7.5 && y >= this.cy - this.h / 2 && y <= this.cy + this.h / 2)
        this.pressed = true;
      else
        this.pressed = false;
      this.hitTest(x, y, false);
    }
  }
  function Button() {
    this.init = function (txt, l, t, w, h) {
      this.txt = txt;
      this.cx = l + w / 2;
      this.cy = t + h / 2;
      this.w = w;
      this.h = h;
      this.hovered = false;
      this.pressed = false;
    }
    this.draw = function () {
      noStroke();
      rectMode(CENTER);
      textAlign(CENTER, CENTER);
      if (this.pressed)
        fill(255, 160, 0);
      else if (this.hovered)
        fill(69, 143, 192);
      else
        fill(143, 192, 69);
      rect(this.cx, this.cy, this.w, this.h, 3);
      fill(255);
      textSize(24);
      text(this.txt, this.cx, this.cy, this.w, this.h);
    }
    this.hitTest = function (x, y) {
      if (x >= this.cx - this.w / 2 && x <= this.cx + this.w / 2 && y >= this.cy - this.h / 2 && y <= this.cy + this.h / 2)
        this.hovered = true;
      else
        this.hovered = false;
    }
    this.clickTest = function (x, y) {
      if (x >= this.cx - this.w / 2 && x <= this.cx + this.w / 2 && y >= this.cy - this.h / 2 && y <= this.cy + this.h / 2)
        this.pressed = true;
      else
        this.pressed = false;
    }
    this.execute = function () {
      if (this.pressed)
        createGame();
    }
  }
  function setup() {
    canvas = createCanvas(boardMargin * 2 + boardSize, headerHeight + boardSize + boardSize / 5 + boardMargin);
    matrix = new Matrix();
    button = new Button();
    button.init("Reset", width - boardMargin - 110, boardMargin, 110, headerHeight - boardMargin * 2);
    sliderSize = new Slider();
    sliderSize.init(0.5, boardMargin + 1, boardMargin, 110, headerHeight - boardMargin * 2);
    sliderRate = new Slider();
    sliderRate.init(0.0, boardMargin + 150, boardMargin, 110, headerHeight - boardMargin * 2);
    canvas.parent('canvas-container');
    createGame();
  }
  function draw() {
    background(255);
    button.draw();
    sliderSize.draw();
    sliderRate.draw();
    matrix.draw(boardMargin, headerHeight, boardSize, boardSize);
  }
  function mouseMoved() {
    button.hitTest(mouseX, mouseY);
    sliderSize.hitTest(mouseX, mouseY, true);
    sliderRate.hitTest(mouseX, mouseY, true);
    matrix.highlight(boardMargin, headerHeight, boardSize, boardSize, mouseX, mouseY);
  }
  function mousePressed() {
    button.clickTest(mouseX, mouseY);
    sliderSize.clickTest(mouseX, mouseY);
    sliderRate.clickTest(mouseX, mouseY);
  }
  function mouseDragged() {
    matrix.highlight(boardMargin, headerHeight, boardSize, boardSize, mouseX, mouseY);
    sliderSize.hitTest(mouseX, mouseY, false);
    sliderRate.hitTest(mouseX, mouseY, false);
  }
  function mouseClicked() {
    button.execute();
    matrix.execute();
    button.clickTest(-1000, -1000);
    sliderSize.clickTest(-1000, -1000);
    sliderRate.clickTest(-1000, -1000);
  }
  function createGame() {
    matrix.init((int)(sliderSize.val * 20 + 10), sliderRate.val * 0.9 + 0.05);
  }
  // ]]></script>
<p>I wrote several blog pieces (in Chinese) to introduce the motivation behind Minimum Regree Reordering algorithms. Such algorithms aim at reducing the fill-in during sparse Cholesky factorization. Here is a simple interative game which illustrates the effect of fill-in during steps of factorization.</p>
<p>The idea of this elimination game originates from a very insightful tutorial written by Stephen Ingram. It can be found <a href="http://www.cs.ubc.ca/~sfingram/cs517_final.pdf">here</a>.</p>
<p>Introduction to the game:<br /> The game operates in Cholesky factorization manner. Each time the player picks a column/row. The selected will be factorized and could possibly generating fill-ins. Fill-ins are displayed in <span style="color: #ffa000;">orange</span> blocks. Two sliders on topmost controls the matrix size and sparsity. Bar graph on the bottom shows the number of non-zeroes of each column, while <span style="color: #458fc0;">blue</span> ticks indicate the smallest among them (equivalently the minimum degree in a factor graph representation). When factorization finished, the number of non-zeroes at beginning/after factorization and the total number of matrix elements are shown.</p>
<div id="canvas-container" style="display: flex; justify-content: center;"></div>
<p>This game is written with <a href="http://p5js.org/">p5.js</a>.</p>
<script src="{{ site.baseurl }}{{ site.assets.scripts }}/p5.min.js"></script>
