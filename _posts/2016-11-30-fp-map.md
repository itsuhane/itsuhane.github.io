---
title: 浮点数的二进制分布
date: 2016-11-30 09:00:03
tag:
- floating point
comment: true
---

先前看到一篇文章，提到了比较两个浮点数的绝对值大小可以如何加速。它的核心解决方案是将 `fabs(a) < fabs(b)` 替换为
~~~ C++
(((std::uint32_t&)a)&0x7FFFFFFF) < (((std::uint32_t&)b)&0x7FFFFFFF)
~~~
即使用它们不带符号位的二进制部分进行大小比较。

这个思路很有趣，于是我思考了一下浮点数在全体可能的二进制组合上有着怎么样的分布（特别是对于 Inf/NaN ，上面的加速会有什么样的行为）。

[image here]

我平常使用 `double` 类型更多（在 x86/amd64 体系下，`double` 和 `float` 具有相同的运算效率，内存开销更大是唯一的问题；在稍微老一些的 CUDA 架构下，`double` 运算可以比 `float` 运算慢 3~24 倍），因此我对 `double` 类型做了上面的图表，横向从左到右代表了从二进制 0 到二进制的最大值，每一段上标注了它们的数值类型。注意上图里宽度并非按照比例。

在图里，我没有考虑符号位。当符号位为 1 的时候，可以简单在数值前加负号（甚至 NaN 也是可以的？？？

从上图的分布总结的话，前面提到的利用二进制整数比较浮点数绝对值大小的方法对于 NaN 以外的数值都是可行的。关于规格化和次规格化数在浮点数下的序如何在整数下保持，只要注意到浮点数的指数部分处于二进制的高位，因而作为主序，便可得知。唯一有意思的是 NaN ，我们知道 NaN 在浮点数中的处理是比较“矛盾”的，它与其它浮点数的比较违背了布尔逻辑。在二进制中，NaN 可以被看做“超级无穷”，即它甚至比无穷还要大。
