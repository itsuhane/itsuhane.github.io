---
layout: page
title: SLAM Evaluation
permalink: /evaluation/
scripts:
  - name: "nanobar.min"
  - name: "jmat.min"
  - name: "plotly.min"
comment: false
datasets:
  - id: "euroc"
    name: "EuRoC"
    sequences:
      - id: "v1-01"
        name: "V1_01_easy"
      - id: "v1-02"
        name: "V1_02_medium"
      - id: "v1-03"
        name: "V1_03_difficult"
      - id: "v2-01"
        name: "V2_01_easy"
      - id: "v2-02"
        name: "V2_02_medium"
      - id: "v2-03"
        name: "V2_03_difficult"
      - id: "mh-01"
        name: "MH_01_easy"
      - id: "mh-02"
        name: "MH_02_easy"
      - id: "mh-03"
        name: "MH_03_medium"
      - id: "mh-04"
        name: "MH_04_difficult"
      - id: "mh-05"
        name: "MH_05_difficult"
---
<style>
.bicolumn {
  display: inline-block;
  width: 48%;
}
.bicolumn select, .bicolumn input {
  width: 100%;
  box-sizing: border-box;
}
.bicolumn dd {
  margin-inline-end: 40px;
}
#plot-container {
  width: 100%;
}
@media (max-width: 30em) {
  .bicolumn {
    width: 98%;
  }
  .bicolumn dl {
    margin: 0;
  }
}
</style>
<div class="bicolumn">
<dl>
  <dt><label for="dataset">Dataset</label></dt>
  <dd><select name="dataset" id="dataset">
  {% for dataset in page.datasets %}
    <option value="{{ dataset.id }}">{{ dataset.name }}</option>
  {% endfor %}
  </select></dd>
  <dt><label for="sequence">Sequence</label></dt>
  <dd><select name="sequence" id="sequence">
  </select></dd>
  <dt><label for="reference">Reference</label></dt>
  <dd><select name="reference" id="reference">
  </select></dd>
</dl>
</div><div class="bicolumn">
<dl>
  <dt><label for="format">Format</label></dt>
  <dd><select name="format" id="format">
    <option value="tum">TUM</option>
    <option value="csv">CSV</option>
  </select></dd>
  <dt><label for="label">Label <small>(Optional)</small></label></dt>
  <dd><input type="text" name="label" id="label" placeholder="&lt;trajectory file name&gt;" /></dd>
  <dt><label for="trajectory">Trajectory</label></dt>
  <dd><input type="file" name="trajectory" id="trajectory" /></dd>
</dl>
</div>
<div class="highlight">
  Information
  <pre id="information" class="highlight"></pre>
</div>
<div id="plot-container"></div>
<p>
  The evaluation is done at browser-side. This page does not upload any information. And the results won't be saved.
</p>
<script>
  var evaluation = (function(de, se, re, fe, le, te, ie) {
    var sequencedata;

    var datasets = {
      {% for dataset in page.datasets %}'{{ dataset.id }}': {
        {% for sequence in dataset.sequences %}'{{ sequence.id }}': {
          'name': '{{ sequence.name }}'
        },
        {% endfor %}
      },
      {% endfor %}
    };

    var progressbar = new Nanobar();
    progressbar.go(0);

    function clearOptions(ce) {
      while(ce.length > 0) {
        ce.remove(0);
      }
    }

    function appendOption(ce,v,t) {
      var option = document.createElement('option');
      option.value = v;
      option.text = t;
      ce.add(option);
    }

    function tum2array(text) {
      return text.split(' ');
    }

    function csv2array(text) {
      var re_valid = /^\s*(?:'[^'\\]*(?:\\[\S\s][^'\\]*)*'|"[^"\\]*(?:\\[\S\s][^"\\]*)*"|[^,'"\s\\]*(?:\s+[^,'"\s\\]+)*)\s*(?:,\s*(?:'[^'\\]*(?:\\[\S\s][^'\\]*)*'|"[^"\\]*(?:\\[\S\s][^"\\]*)*"|[^,'"\s\\]*(?:\s+[^,'"\s\\]+)*)\s*)*$/;
      var re_value = /(?!\s*$)\s*(?:'([^'\\]*(?:\\[\S\s][^'\\]*)*)'|"([^"\\]*(?:\\[\S\s][^"\\]*)*)"|([^,'"\s\\]*(?:\s+[^,'"\s\\]+)*))\s*(?:,|$)/g;
      if (!re_valid.test(text)) return null;
      var a = [];
      text.replace(re_value,
        function(m0, m1, m2, m3) {
            if      (m1 !== undefined) a.push(m1.replace(/\\'/g, "'"));
            else if (m2 !== undefined) a.push(m2.replace(/\\"/g, '"'));
            else if (m3 !== undefined) a.push(m3);
            return '';
        }
      );
      if (/,\s*$/.test(text)) a.push('');
      return a;
    };

    var parsers = {
      tum: tum2array,
      csv: csv2array
    };

    function array2traj(arr) {
      var num = arr.map(Number.parseFloat);
      if(num.length!==8) {
        console.log('Mal-formed line skipped.');
        return null;
      }
      return {
        t: num[0],
        q_ws: [ num[4], num[5], num[6], num[7] ],
        p_ws: [ num[1], num[2], num[3] ]
      };
    }

    function scale(s, v) {
      return v.map(x => s*x);
    }

    function squaredNorm(v) {
      return v.reduce((s, x) => s + x*x, 0);
    }

    function norm(v) {
      return Math.sqrt(squaredNorm(v));
    }

    function stableNorm(v) {
      let s = Math.max(v.map(Math.abs));
      if(s>1.0e9) {
        let sv = scale(1.0/s, v);
        return s * norm(sv);
      } else {
        return norm(v);
      }
    }

    function normalize(v) {
      return scale(1.0/norm(v), v);
    }

    function stableNormalize(v) {
      let s = Math.max(v.map(Math.abs));
      if(s>1.0e9) {
        let sv = scale(1.0/s, v);
        return normalize(sv);
      } else if(s>1.0e-9) {
        return normalize(v)
      } else {
        return v;
      }
    }

    function conjugate(q) {
      return [ -q[0], -q[1], -q[2], q[3] ];
    }

    function expmap(w) {
      let halfangle = 0.5*norm(w);
      let axis = stableNormalize(w);
      let imagine = scale(Math.sin(halfangle), axis);
      let real = Math.cos(halfangle);
      return [ imagine[0], imagine[1], imagine[2], real ];
    }

    function logmap(q) {
      let saxis = [ q[0], q[1], q[2] ];
      let coshalfangle = q[3];
      let sinhalfangle = norm(saxis);
      let angle = 2.0*Math.atan2(sinhalfangle, coshalfangle);
      return scale(angle, stableNormalize(saxis));
    }

    function add(v1, v2) {
      return v1.map((x, i) => x + v2[i]);
    }

    function sub(v1, v2) {
      return v1.map((x, i) => x - v2[i]);
    }

    function dot(v1, v2) {
      return v1.reduce((s, x, i) => s + x*v2[i], 0);
    }

    function mult(q1, q2) {
      return [
         q1[0]*q2[3] + q1[1]*q2[2] - q1[2]*q2[1] + q1[3]*q2[0],
        -q1[0]*q2[2] + q1[1]*q2[3] + q1[2]*q2[0] + q1[3]*q2[1],
         q1[0]*q2[1] - q1[1]*q2[0] + q1[2]*q2[3] + q1[3]*q2[2],
        -q1[0]*q2[0] - q1[1]*q2[1] - q1[2]*q2[2] + q1[3]*q2[3]
      ];
    }

    function toMatrix(q) {
      let x2 = q[0] + q[0];
      let y2 = q[1] + q[1];
      let z2 = q[2] + q[2];
      let w2 = q[3] + q[3];
      let yy2 = q[1] * y2;
      let xy2 = q[0] * y2;
      let xz2 = q[0] * z2;
      let yz2 = q[1] * z2;
      let zz2 = q[2] * z2;
      let wz2 = q[3] * z2;
      let wy2 = q[3] * y2;
      let wx2 = q[3] * x2;
      let xx2 = q[0] * x2;
      return [
        [1 - yy2 - zz2, xy2 + wz2, xz2 - wy2],
        [xy2 - wz2, 1 - xx2 - zz2, yz2 + wx2],
        [xz2 + wy2, yz2 - wx2, 1 - xx2 - yy2]
      ];
    }

    function toQuaternion(m) {
      if(m[0][0] + m[1][1] + m[2][2] > 0) {
        let t = 1 + m[0][0] + m[1][1] + m[2][2];
        let s = 0.5 / Math.sqrt(t);
        return [ (m[1][2]-m[2][1])*s, (m[2][0]-m[0][2])*s, (m[0][1]-m[1][0])*s, t*s ];
      } else if(m[0][0] > m[1][1] && m[0][0] > m[2][2]) {
        let t = 1 + m[0][0] - m[1][1] - m[2][2];
        let s = 0.5 / Math.sqrt(t);
        return [ t*s, (m[0][1]+m[1][0])*s, (m[2][0]+m[0][2])*s, (m[1][2]-m[2][1])*s ];
      } else if(m[1][1] > m[2][2]) {
        let t = 1 - m[0][0] + m[1][1] - m[2][2];
        let s = 0.5 / Math.sqrt(t);
        return [ (m[0][1]+m[1][0])*s, t*s, (m[1][2]+m[2][1])*s, (m[2][0]-m[0][2])*s ];
      } else {
        let t = 1 - m[0][0] - m[1][1] + m[2][2];
        let s = 0.5 / Math.sqrt(t);
        return [ (m[2][0]+m[0][2])*s, (m[1][2]+m[2][1])*s, t*s, (m[0][1]-m[1][0])*s ];
      }
    }

    function rotate(q, v) {
      return toMatrix(q).map( r => dot(r, v));
    }

    function lerp(l, v1, v2) {
      return v1.map((x, i) => x + l*(v2[i] - x));
    }

    function slerp(l, q1, q2) {
      let qj = q2;
      let d = dot(q1, qj);
      if(d < 0) {
        d = -d;
        qj = scale(-1, q2);
      }
      if(d>0.9995) {
        return normalize(lerp(l, q1, q2));
      }
      let th1 = Math.acos(d);
      let th = th1*l;
      let sinth1 = Math.sin(th1);
      let sinth = Math.sin(th);
      let s2 = sinth/sinth1;
      let s1 = Math.cos(th) - d*s2;
      return normalize(add(scale(s1, q1), scale(s2, q2)));
    }

    function body2sensor(btraj, sensor) {
      return btraj.map(u => {
        return {
          t: u.t,
          q_ws: mult(u.q_wb, sensor.q_bs),
          p_ws: add(u.p_wb, rotate(u.q_wb, sensor.p_bs))
        };
      });
    }

    function sampleFromSequence(sequence, t) {
      function binarySearch(sd, pred) {
        let lo = -1, hi = sd.length;
        while (1 + lo < hi) {
          const mi = lo + ((hi - lo) >> 1);
          if (pred(sd[mi])) {
            hi = mi;
          } else {
            lo = mi;
          }
        }
        return hi;
      }
      if(t < sequence.trajectory[0].t) return sequence.trajectory[0];
      if(t > sequence.trajectory[sequence.trajectory.length-1].t) return sequence.trajectory[sequence.trajectory.length-1];
      let i = binarySearch(sequence.trajectory, x => t <= x.t);
      if(t===sequence.trajectory[i]) {
        return sequence.trajectory[i];
      } else {
        let e0 = sequence.trajectory[i-1];
        let e1 = sequence.trajectory[i];
        let l = (t-e0.t)/(e1.t-e0.t);
        return {
          t: t,
          q_wb: slerp(l, e0.q_wb, e1.q_wb),
          p_wb: lerp(l, e0.p_wb, e1.p_wb)
        };
      }
    }

    // (Q*traj1+T) = S*traj2
    function umeyama(traj1, traj2, fix_scale) {
      let ps1 = traj1.map(u => u.p_ws);
      let ps2 = traj2.map(u => u.p_ws);
      let cog1 = scale(1.0/ps1.length, ps1.reduce((p, x) => add(p, x), [0, 0, 0]));
      let cog2 = scale(1.0/ps2.length, ps2.reduce((p, x) => add(p, x), [0, 0, 0]));
      let ps1_centered = ps1.map(x => sub(x, cog1));
      let ps2_centered = ps2.map(x => sub(x, cog2));
      let var1 = Math.sqrt(ps1_centered.reduce((v, x) => v+squaredNorm(x), 0));
      let var2 = Math.sqrt(ps2_centered.reduce((v, x) => v+squaredNorm(x), 0));
      let S = var1/var2;
      let ps2_scaled = ps2_centered.map(x => scale(S, x));
      let cov = ps1_centered.reduce((s, x, i) => {
        let y = ps2_scaled[i];
        return [add(s[0],scale(x[0],y)),add(s[1],scale(x[1],y)),add(s[2],scale(x[2],y))];
      }, [[0,0,0],[0,0,0],[0,0,0]]).map(c => scale(1.0/ps1.length, c));
      let svd = Jmat.svd(cov);
      let E = [[1,0,0],[0,1,0],[0,0,1]];
      if(Jmat.determinant(svd.v.mul(svd.u.transpose())).re < 0.0) {
        E[2][2] = -1;
      }
      let matR = svd.v.mul(Matrix(E)).mul(svd.u.transpose());
      let R = [
        matR.e[0].map(c => c.re),
        matR.e[1].map(c => c.re),
        matR.e[2].map(c => c.re)
      ];
      let T = sub(scale(S,cog2), R.map(r => dot(r,cog1)));
      return { S: S, Q: toQuaternion(R), T: T };
    }

    function computeStats(l) {
      let err = l.sort((a, b) => a - b);
      let min_error = Math.min.apply(Math, err);
      let max_error = Math.max.apply(Math, err);
      let mean_error = err.reduce((s, e) => s + e, 0) / err.length;
      let median_error = err[err.length >> 1];
      let rmse_error = Math.sqrt(err.reduce((r, e) => r + e*e, 0) / err.length);
      return {
        rmse: rmse_error,
        min: min_error,
        max: max_error,
        mean: mean_error,
        median: median_error
      };
    }

    function evaluateTrajectory(label, gttraj, traj) {
      let sim = umeyama(traj, gttraj);
      let errors = traj.map(
        (u, i) => {
          let dp = sub(scale(sim.S, gttraj[i].p_ws), add(rotate(sim.Q, u.p_ws), sim.T));
          let dq = logmap(mult(conjugate(mult(sim.Q, u.q_ws)), gttraj[i].q_ws));
          return { t: u.t, p: Math.sqrt(dot(dp, dp)), q: Math.sqrt(dot(dq, dq)) };
        }
      );
      let p_errors = errors.map(x => x.p);
      let q_errors = errors.map(x => x.q);
      let p_stat = computeStats(p_errors);
      let q_stat = computeStats(q_errors);
      let dataset = de.options[de.selectedIndex].text + '/' + se.options[se.selectedIndex].text;
      let messages = [
        'Dataset:  ' + dataset,
        'Label:    ' + label,
        'Scale:    ' + Number.parseFloat(sim.S).toFixed(5),
        'APE:',
        '  rmse:   ' + Number.parseFloat(p_stat.rmse).toFixed(5),
        '  min:    ' + Number.parseFloat(p_stat.min).toFixed(5),
        '  max:    ' + Number.parseFloat(p_stat.max).toFixed(5),
        '  mean:   ' + Number.parseFloat(p_stat.mean).toFixed(5),
        '  median: ' + Number.parseFloat(p_stat.median).toFixed(5),
        // 'ARE:',
        // '  rmse:   ' + Number.parseFloat(q_stat.rmse).toFixed(5),
        // '  min:    ' + Number.parseFloat(q_stat.min).toFixed(5),
        // '  max:    ' + Number.parseFloat(q_stat.max).toFixed(5),
        // '  mean:   ' + Number.parseFloat(q_stat.mean).toFixed(5),
        // '  median: ' + Number.parseFloat(q_stat.median).toFixed(5),
      ];
      ie.textContent = messages.join('\n');
    }

    function refreshSequences() {
      clearOptions(se);
      appendOption(se, '(sequence)', '(select sequence)');
      se.disabled = true;
      var sequences = datasets[de.options[de.selectedIndex].value]
      for(s in sequences) {
        appendOption(se, s, sequences[s].name);
        se.disabled = false;
      }
      refreshReferences();
    }

    function requestSequence(url) {
      var pseudo_remaining = 100;
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.onprogress = function(e) {
        var progress = 0;
        if(e.lengthComputable) {
          progress = 100 * e.loaded/e.total;
        } else {
          pseudo_remaining = pseudo_remaining * (0.93 + Math.random() * 0.04);
          progress = 100 - pseudo_remaining;
        }
        progressbar.go(Math.max(progress, 1.0));
      };
      xhr.onload = function(e) {
        if(xhr.readyState === 4 && xhr.status === 200) {
          progressbar.go(100);
          sequencedata = JSON.parse(xhr.responseText);
          for(r in sequencedata.sensors) {
            appendOption(re, r, sequencedata.sensors[r].name);
          }
          re.disabled = false;
        } else {
          console.error(xhr.statusText);
        }
        progressbar.go(0);
      };
      xhr.onabort = function(e) {
        progressbar.go(0);
      };
      xhr.onerror = function(e) {
        console.error(xhr.statusText);
        progressbar.go(0);
      };
      progressbar.go(1);
      xhr.send(null);
      return xhr;
    }

    var xhr;
    function refreshReferences() {
      clearOptions(re);
      appendOption(re, '(reference)', '(select reference)');
      sequencedata = null;
      re.disabled = true;
      if(xhr) {
        xhr.abort();
      }
      var sequence = se.options[se.selectedIndex].value;
      if(!(sequence==='(sequence)')) {
        var dataset = de.options[de.selectedIndex].value;
        var url = '/datasets/'+dataset+'/'+sequence+'/';
        xhr = requestSequence(url);
      }
      refreshChooser();
    }

    function refreshFormatInformation() {
      var format = fe.options[fe.selectedIndex].value;
      if(format==='tum') {
        ie.textContent = 'Trajectory File Format:\n<t[s]> <p.x[m]> <p.y[m]> <p.z[m]> <q.x> <q.y> <q.z> <q.w>';
      }
      if(format==='csv') {
        ie.textContent = 'Trajectory File Format:\n<t[s]>,<p.x[m]>,<p.y[m]>,<p.z[m]>,<q.x>,<q.y>,<q.z>,<q.w>';
      }
    }

    function refreshChooser() {
      var reference = re.options[re.selectedIndex].value;
      te.value = '';
      te.disabled = (reference==='(reference)');
    }

    function loadTrajectory(e) {
      var files = e.target.files;
      if(files.length=== 0) return;
      var trajfile = files[0];
      var label = le.value ? le.value : trajfile.name;
      var reader = new FileReader();
      reader.onload = (function(f) {
        return function(e) {
          var traj = e.target.result
            .split('\n')
            .map(parsers[fe.options[fe.selectedIndex].value])
            .map(array2traj)
            .filter(function(v) { return v!== null;});
          var sensor = sequencedata.sensors[re.options[re.selectedIndex].value];
          var gttraj = body2sensor(traj.map(u => sampleFromSequence(sequencedata, u.t)), sensor);
          evaluateTrajectory(label, gttraj, traj);
        };
      })(trajfile);
      reader.readAsText(trajfile);
      te.value = '';
    }

    de.addEventListener('change', refreshSequences, false);
    se.addEventListener('change', refreshReferences, false);
    fe.addEventListener('change', refreshFormatInformation, false);
    re.addEventListener('change', refreshChooser, false);
    te.addEventListener('change', loadTrajectory, false);
    refreshSequences();
    refreshFormatInformation();

    return true;
  })(
    document.getElementById('dataset'),
    document.getElementById('sequence'),
    document.getElementById('reference'),
    document.getElementById('format'),
    document.getElementById('label'),
    document.getElementById('trajectory'),
    document.getElementById('information')
  );
</script>

<!--
<script>
  const urlParams = new URLSearchParams(window.location.search);
  const group = urlParams.get('group');
  const traj = urlParams.get('traj');
  const dataset = "{{ site.url }}{{ site.base_url }}/datasets/"+group+"/"+traj+"/";
  console.log(dataset);
  function unpack(arr, key) {
    return arr.map(function(e) {
      return e[key];
    });
  }
  Plotly.d3.json(dataset,
    function(err, data) {
      console.log(err);
      var pos = unpack(data.trajectory, 'p_wb');
      var x = unpack(pos, '0');
      var y = unpack(pos, '1');
      var z = unpack(pos, '2');
      Plotly.plot('plot_canvas', [{
        type: 'scatter3d',
        mode: 'lines',
        x: x,
        y: y,
        z: z,
        opacity: 1
      }], {
        autosize: true,
        margin: { l: 0, r: 0, b:0, t:0 },
        scene: {
          aspectmode: 'data'
        }
      }, { responsive:true });
    }
  )
  window.onresize = function () {
    Plotly.Plots.resize('plot_canvas');
  };
</script>
-->
{% include features/disqus %}
